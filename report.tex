% !TeX TXS-program:bibliography = txs:///biber
\documentclass[14pt, russian]{scrartcl}

\let\counterwithout\relax
\let\counterwithin\relax
% \usepackage{lmodern}
\usepackage{float}
\usepackage{xcolor}
\usepackage{extsizes}
% \usepackage{subfig}
\usepackage[export]{adjustbox}
\usepackage{tocvsec2} % возможность менять учитываемую глубину разделов в оглавлении
% \usepackage[subfigure]{tocloft}
\usepackage[newfloat]{minted}
% \captionsetup[listing]{position=top}

\usepackage{fancyvrb}
\usepackage{ulem,bm,mathrsfs,ifsym} %зачеркивания, особо жирный стиль и RSFS начертание
% \usepackage{sectsty} % переопределение стилей подразделов
%%%%%%%%%%%%%%%%%%%%%%%

%%% Поля и разметка страницы %%%
% \usepackage{pdflscape}                              % Для включения альбомных страниц
\usepackage{geometry}                               % Для последующего задания полей
\geometry{a4paper,tmargin=2cm,bmargin=2cm,lmargin=3cm,rmargin=1cm} % тоже самое, но лучше

%%% Математические пакеты %%%
\usepackage{amsthm,amsfonts,amsmath,amssymb,amscd}  % Математические дополнения от AMS
\usepackage{mathtools}                              % Добавляет окружение multlined
\usepackage[perpage]{footmisc}
\usepackage{times}

%%%% Установки для размера шрифта 14 pt %%%%
%% Формирование переменных и констант для сравнения (один раз для всех подключаемых файлов)%%
%% должно располагаться до вызова пакета fontspec или polyglossia, потому что они сбивают его работу
\newlength{\curtextsize}
\newlength{\bigtextsize}
\setlength{\bigtextsize}{13pt}
\KOMAoptions{fontsize=14pt}

\makeatletter
\def\showfontsize{\f@size{} point}
\makeatother

%\makeatletter
%\show\f@size                                       % неплохо для отслеживания, но вызывает стопорение процесса, если документ компилируется без команды  -interaction=nonstopmode 
%\setlength{\curtextsize}{\f@size pt}
%\makeatother

%шрифт times
\usepackage{tempora} %только для тех, у кого MikTeX последней версии и не ловит pscyr
% \setmainfont{Times New Roman}
% \usepackage{pscyr} %для всех нормальных людей
% \setmainfont[Ligatures={TeX,Historic}]{Times New Roman}

   %%% Решение проблемы копирования текста в буфер кракозябрами
%    \input glyphtounicode.tex
%    \input glyphtounicode-cmr.tex %from pdfx package
%    \pdfgentounicode=1
    % \usepackage{cmap}                               % Улучшенный поиск русских слов в полученном pdf-файле
    \usepackage[T1]{fontenc}                       % Поддержка русских букв
    \usepackage[utf8]{inputenc}                     % Кодировка utf8
    \usepackage[english, main=russian]{babel}            % Языки: русский, английский
%   \IfFileExists{pscyr.sty}{\usepackage{pscyr}}{}  % Красивые русские шрифты
%\renewcommand{\rmdefault}{ftm}
%%% Оформление абзацев %%%
\usepackage{indentfirst}                            % Красная строка
% \usepackage{eskdpz}

%%% Таблицы %%%
\usepackage{longtable}                              % Длинные таблицы
\usepackage{multirow,makecell,array}                % Улучшенное форматирование таблиц
\usepackage{booktabs}                               % Возможность оформления таблиц в классическом книжном стиле (при правильном использовании не противоречит ГОСТ)

%%% Общее форматирование
\usepackage{soulutf8}                               % Поддержка переносоустойчивых подчёркиваний и зачёркиваний
\usepackage{icomma}                                 % Запятая в десятичных дробях



%%% Изображения %%%
\usepackage{graphicx}                               % Подключаем пакет работы с графикой
\usepackage{wrapfig}

%%% Списки %%%
\usepackage{enumitem}

%%% Подписи %%%
\usepackage{caption}                                % Для управления подписями (рисунков и таблиц) % Может управлять номерами рисунков и таблиц с caption %Иногда может управлять заголовками в списках рисунков и таблиц
%% Использование:
%\begin{table}[h!]\ContinuedFloat - чтобы не переключать счетчик
%\captionsetup{labelformat=continued}% должен стоять до самого caption
%\caption{}
% либо ручками \caption*{Продолжение таблицы~\ref{...}.} :)

\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}
  
%%% Интервалы %%%
\addto\captionsrussian{%
  \renewcommand{\listingname}{Листинг}%
}
%%% Счётчики %%%
\usepackage[figure,table,section]{totalcount}               % Счётчик рисунков и таблиц
\DeclareTotalCounter{lstlisting}
\usepackage{totcount}                               % Пакет создания счётчиков на основе последнего номера подсчитываемого элемента (может требовать дважды компилировать документ)
\usepackage{totpages}                               % Счётчик страниц, совместимый с hyperref (ссылается на номер последней страницы). Желательно ставить последним пакетом в преамбуле

%%% Продвинутое управление групповыми ссылками (пока только формулами) %%%
%% Кодировки и шрифты %%%


%    \IfFileExists{pscyr.sty}{\renewcommand{\rmdefault}{ftm}}{}
%%% Интервалы %%%
%linespread-реализация ближе к реализации полуторного интервала в ворде.
%setspace реализация заточена под шрифты 10, 11, 12pt, под остальные кегли хуже, но всё же ближе к типографской классике. 
\linespread{1.3}                    % Полуторный интервал (ГОСТ Р 7.0.11-2011, 5.3.6)
% \renewcommand{\@biblabel}[1]{#1}

%%% Гиперссылки %%%
% \usepackage{hyperref}

%%% Выравнивание и переносы %%%
\sloppy                             % Избавляемся от переполнений
\clubpenalty=10000                  % Запрещаем разрыв страницы после первой строки абзаца
\widowpenalty=10000                 % Запрещаем разрыв страницы после последней строки абзаца

\makeatletter % малые заглавные, small caps shape
\let\@@scshape=\scshape
\renewcommand{\scshape}{%
  \ifnum\strcmp{\f@series}{bx}=\z@
    \usefont{T1}{cmr}{bx}{sc}%
  \else
    \ifnum\strcmp{\f@shape}{it}=\z@
      \fontshape{scsl}\selectfont
    \else
      \@@scshape
    \fi
  \fi}
\makeatother

\AtBeginEnvironment{minted}{%
  \renewcommand{\fcolorbox}[4][]{#4}}
  
%%% Подписи %%%
%\captionsetup{%
%singlelinecheck=off,                % Многострочные подписи, например у таблиц
%skip=2pt,                           % Вертикальная отбивка между подписью и содержимым рисунка или таблицы определяется ключом
%justification=centering,            % Центрирование подписей, заданных командой \caption
%}
%%%        Подключение пакетов                 %%%
\usepackage{ifthen}                 % добавляет ifthenelse
%%% Инициализирование переменных, не трогать!  %%%
\newcounter{intvl}
\newcounter{otstup}
\newcounter{contnumeq}
\newcounter{contnumfig}
\newcounter{contnumtab}
\newcounter{pgnum}
\newcounter{bibliosel}
\newcounter{chapstyle}
\newcounter{headingdelim}
\newcounter{headingalign}
\newcounter{headingsize}
\newcounter{tabcap}
\newcounter{tablaba}
\newcounter{tabtita}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Область упрощённого управления оформлением %%%

%% Интервал между заголовками и между заголовком и текстом
% Заголовки отделяют от текста сверху и снизу тремя интервалами (ГОСТ Р 7.0.11-2011, 5.3.5)
\setcounter{intvl}{3}               % Коэффициент кратности к размеру шрифта

%% Отступы у заголовков в тексте
\setcounter{otstup}{0}              % 0 --- без отступа; 1 --- абзацный отступ

%% Нумерация формул, таблиц и рисунков
\setcounter{contnumeq}{1}           % Нумерация формул: 0 --- пораздельно (во введении подряд, без номера раздела); 1 --- сквозная нумерация по всей диссертации
\setcounter{contnumfig}{1}          % Нумерация рисунков: 0 --- пораздельно (во введении подряд, без номера раздела); 1 --- сквозная нумерация по всей диссертации
\setcounter{contnumtab}{1}          % Нумерация таблиц: 0 --- пораздельно (во введении подряд, без номера раздела); 1 --- сквозная нумерация по всей диссертации

%% Оглавление
\setcounter{pgnum}{0}               % 0 --- номера страниц никак не обозначены; 1 --- Стр. над номерами страниц (дважды компилировать после изменения)

%% Библиография
% \bibliography{biblio.bib}
% \addbibresource{biblio.bib}
% \setcounter{bibliosel}{0}           % 0 --- встроенная реализация с загрузкой файла через движок bibtex8; 1 --- реализация пакетом biblatex через движок biber

%% Текст и форматирование заголовков
\setcounter{chapstyle}{1}           % 0 --- разделы только под номером; 1 --- разделы с названием "Глава" перед номером
\setcounter{headingdelim}{1}        % 0 --- номер отделен пропуском в 1em или \quad; 1 --- номера разделов и приложений отделены точкой с пробелом, подразделы пропуском без точки; 2 --- номера разделов, подразделов и приложений отделены точкой с пробелом.

%% Выравнивание заголовков в тексте
\setcounter{headingalign}{0}        % 0 --- по центру; 1 --- по левому краю

%% Размеры заголовков в тексте
\setcounter{headingsize}{0}         % 0 --- по ГОСТ, все всегда 14 пт; 1 --- пропорционально изменяющийся размер в зависимости от базового шрифта

%% Подпись таблиц
\setcounter{tabcap}{0}              % 0 --- по ГОСТ, номер таблицы и название разделены тире, выровнены по левому краю, при необходимости на нескольких строках; 1 --- подпись таблицы не по ГОСТ, на двух и более строках, дальнейшие настройки: 
%Выравнивание первой строки, с подписью и номером
\setcounter{tablaba}{2}             % 0 --- по левому краю; 1 --- по центру; 2 --- по правому краю
%Выравнивание строк с самим названием таблицы
\setcounter{tabtita}{1}             % 0 --- по левому краю; 1 --- по центру; 2 --- по правому краю

%%% Рисунки %%%
\DeclareCaptionLabelSeparator*{emdash}{~--- }             % (ГОСТ 2.105, 4.3.1)
\captionsetup[figure]{labelsep=emdash,font=onehalfspacing,position=bottom}

%%% Таблицы %%%
\ifthenelse{\equal{\thetabcap}{0}}{%
    \newcommand{\tabcapalign}{\raggedright}  % по левому краю страницы или аналога parbox
}

\ifthenelse{\equal{\thetablaba}{0} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabcapalign}{\raggedright}  % по левому краю страницы или аналога parbox
}

\ifthenelse{\equal{\thetablaba}{1} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabcapalign}{\centering}    % по центру страницы или аналога parbox
}

\ifthenelse{\equal{\thetablaba}{2} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabcapalign}{\raggedleft}   % по правому краю страницы или аналога parbox
}

\ifthenelse{\equal{\thetabtita}{0} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabtitalign}{\raggedright}  % по левому краю страницы или аналога parbox
}

\ifthenelse{\equal{\thetabtita}{1} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabtitalign}{\centering}    % по центру страницы или аналога parbox
}

\ifthenelse{\equal{\thetabtita}{2} \AND \equal{\thetabcap}{1}}{%
    \newcommand{\tabtitalign}{\raggedleft}   % по правому краю страницы или аналога parbox
}

\DeclareCaptionFormat{tablenocaption}{\tabcapalign #1\strut}        % Наименование таблицы отсутствует
\ifthenelse{\equal{\thetabcap}{0}}{%
    \DeclareCaptionFormat{tablecaption}{\tabcapalign #1#2#3}
    \captionsetup[table]{labelsep=emdash}                       % тире как разделитель идентификатора с номером от наименования
}{%
    \DeclareCaptionFormat{tablecaption}{\tabcapalign #1#2\par%  % Идентификатор таблицы на отдельной строке
        \tabtitalign{#3}}                                       % Наименование таблицы строкой ниже
    \captionsetup[table]{labelsep=space}                        % пробельный разделитель идентификатора с номером от наименования
}
\captionsetup[table]{format=tablecaption,singlelinecheck=off,font=onehalfspacing,position=top,skip=-5pt}  % многострочные наименования и прочее
\DeclareCaptionLabelFormat{continued}{Продолжение таблицы~#2}
\setlength{\belowcaptionskip}{.2cm}
\setlength{\intextsep}{0ex}

%%% Подписи подрисунков %%%
% \renewcommand{\thesubfigure}{\asbuk{subfigure}}           % Буквенные номера подрисунков
% \captionsetup[subfigure]{font={normalsize},               % Шрифт подписи названий подрисунков (не отличается от основного)
%     labelformat=brace,                                    % Формат обозначения подрисунка
%     justification=centering,                              % Выключка подписей (форматирование), один из вариантов            
% }
%\DeclareCaptionFont{font12pt}{\fontsize{12pt}{13pt}\selectfont} % объявляем шрифт 12pt для использования в подписях, тут же надо интерлиньяж объявлять, если не наследуется
%\captionsetup[subfigure]{font={font12pt}}                 % Шрифт подписи названий подрисунков (всегда 12pt)

%%% Настройки гиперссылок %%%

\definecolor{linkcolor}{rgb}{0.0,0,0}
\definecolor{citecolor}{rgb}{1.0,0.0,0}
\definecolor{urlcolor}{rgb}{0,0,0}

% \hypersetup{
%     linktocpage=true,           % ссылки с номера страницы в оглавлении, списке таблиц и списке рисунков
% %    linktoc=all,                % both the section and page part are links
% %    pdfpagelabels=false,        % set PDF page labels (true|false)
%     plainpages=true,           % Forces page anchors to be named by the Arabic form  of the page number, rather than the formatted form
%     colorlinks,                 % ссылки отображаются раскрашенным текстом, а не раскрашенным прямоугольником, вокруг текста
%     linkcolor={linkcolor},      % цвет ссылок типа ref, eqref и подобных
%     citecolor={citecolor},      % цвет ссылок-цитат
%     urlcolor={urlcolor},        % цвет гиперссылок
%     pdflang={ru},
% }
% \urlstyle{same}
%%% Шаблон %%%
%\DeclareRobustCommand{\todo}{\textcolor{red}}       % решаем проблему превращения названия цвета в результате \MakeUppercase, http://tex.stackexchange.com/a/187930/79756 , \DeclareRobustCommand protects \todo from expanding inside \MakeUppercase
\setlength{\parindent}{2.5em}                       % Абзацный отступ. Должен быть одинаковым по всему тексту и равен пяти знакам (ГОСТ Р 7.0.11-2011, 5.3.7).

%%% Списки %%%
% Используем дефис для ненумерованных списков (ГОСТ 2.105-95, 4.1.7)
%\renewcommand{\labelitemi}{\normalfont\bfseries~{---}} 
\renewcommand{\labelitemi}{\bfseries~{---}} 
\setlist{nosep,%                                    % Единый стиль для всех списков (пакет enumitem), без дополнительных интервалов.
    labelindent=\parindent,leftmargin=*%            % Каждый пункт, подпункт и перечисление записывают с абзацного отступа (ГОСТ 2.105-95, 4.1.8)
}
%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{xltxtra} % load xunicode

\usepackage{ragged2e}
\usepackage[explicit]{titlesec}
\usepackage{placeins}
\usepackage{xparse}
\usepackage{csquotes}

\usepackage{listingsutf8}
\usepackage{url} %пакеты расширений
\usepackage{algorithm, algorithmicx}
\usepackage[noend]{algpseudocode}
\usepackage{blkarray}
\usepackage{chngcntr}
\usepackage{tabularx}
\usepackage[%
  style=ieee,
  isbn=true,
  url=true,
  defernumbers=true,
  bibencoding=utf8,
  backend=biber,
%   language=auto,    % get main language from babel
%   autolang=other,
]{biblatex}
\newcommand*\template[1]{\text{<}#1\text{>}}
% \addbibresource{biblio.bib}
\bibliography{biblio} %здесь ничего не меняем, кроме, возможно, имени bib-файла

  
\titleformat{name=\section,numberless}[block]{\normalfont\large\centering}{}{0em}{#1}
\titleformat{\section}[block]{\normalfont\large\bfseries\raggedright}{}{0em}{\thesection\hspace{0.25em}#1}
\titleformat{\subsection}[block]{\normalfont\large\bfseries\raggedright}{}{0em}{\thesubsection\hspace{0.25em}#1}
\titleformat{\subsubsection}[block]{\normalfont\large\bfseries\raggedright}{}{0em}{\thesubsubsection\hspace{0.25em}#1}

\let\Algorithm\algorithm
\renewcommand\algorithm[1][]{\Algorithm[#1]\setstretch{1.5}}
%\renewcommand{\listingscaption}{Листинг}

\usepackage{pifont}
\usepackage{calc}
\usepackage{suffix}
\usepackage{csquotes}
\DeclareQuoteStyle{russian}
    {\guillemotleft}{\guillemotright}[0.025em]
    {\quotedblbase}{\textquotedblleft}
\ExecuteQuoteOptions{style=russian}
\newcommand{\enq}[1]{\enquote{#1}}  
\newcommand{\eng}[1]{\begin{english}#1\end{english}}
% Подчиненные счетчики в окружениях http://old.kpfu.ru/journals/izv_vuz/arch/sample1251.tex
\newcounter{cTheorem} 
\newcounter{cDefinition}
\newcounter{cConsequent}
\newcounter{cExample}
\newcounter{cLemma}
\newcounter{cConjecture}
\newtheorem{Theorem}{Теорема}[cTheorem]
\newtheorem{Definition}{Определение}[cDefinition]
\newtheorem{Consequent}{Следствие}[cConsequent]
\newtheorem{Example}{Пример}[cExample]
\newtheorem{Lemma}{Лемма}[cLemma]
\newtheorem{Conjecture}{Гипотеза}[cConjecture]

\renewcommand{\theTheorem}{\arabic{Theorem}}
\renewcommand{\theDefinition}{\arabic{Definition}}
\renewcommand{\theConsequent}{\arabic{Consequent}}
\renewcommand{\theExample}{\arabic{Example}}
\renewcommand{\theLemma}{\arabic{Lemma}}
\renewcommand{\theConjecture}{\arabic{Conjecture}}
%\makeatletter
\NewDocumentCommand{\Newline}{}{\text{\\}}
\newcommand{\sequence}[2]{\ensuremath \left(#1,\ \dots,\ #2\right)}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\renewcommand{\listalgorithmname}{Список алгоритмов}
\floatname{algorithm}{Листинг}
\renewcommand{\lstlistingname}{Листинг}
\renewcommand{\thealgorithm}{\arabic{algorithm}}

\newcommand{\refAlgo}[1]{(листинг \ref{#1})}
\newcommand{\refImage}[1]{(рисунок \ref{#1})}

\renewcommand{\theenumi}{\arabic{enumi}.}% Меняем везде перечисления на цифра.цифра	
\renewcommand{\labelenumi}{\arabic{enumi}.}% Меняем везде перечисления на цифра.цифра
\renewcommand{\theenumii}{\arabic{enumii}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumii}{(\arabic{enumii})}% Меняем везде перечисления на цифра.цифра
\renewcommand{\theenumiii}{\roman{enumiii}}% Меняем везде перечисления на цифра.цифра
\renewcommand{\labelenumiii}{(\roman{enumiii})}% Меняем везде перечисления на цифра.цифра
%\newfontfamily\AnkaCoder[Path=src/fonts/]{AnkaCoder-r.ttf}
\renewcommand{\labelitemi}{---}
\renewcommand{\labelitemii}{---}

%\usepackage{courier}

% \lstdefinelanguage{Refal}{
%   alsodigit = {.,<,>},
%   morekeywords = [1]{$ENTRY},
%   morekeywords = [2]{Go, Put, Get, Open, Close, Arg, Add, Sub, Mul, Div, Symb, Explode, Implode},
%   %keyword4
%   morekeywords = [3]{<,>},
%   %keyword5
%   morekeywords = [4]{e.,t.,s.},
%   sensitive = true,
%   morecomment = [l]{*},
%   morecomment = [s]{/*}{*/},
%   commentstyle = \color{mygreen},
%   morestring = [b]",
%   morestring = [b]',
%   stringstyle = \color{purple}
% }

\makeatletter
\def\p@subsection{}
\def\p@subsubsection{\thesection\,\thesubsection\,}
\makeatother
\newcommand{\prog}[1]{{\ttfamily\small#1}}
% \lstset{ %
%   backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
%   basicstyle=\ttfamily\footnotesize, 
%   %basicstyle=\footnotesize\AnkaCoder,        % the size of the fonts that are used for the code
%   breakatwhitespace=false,         % sets if automatic breaks shoulbd only happen at whitespace
%   breaklines=true,                 % sets automatic line breaking
%   captionpos=top,                    % sets the caption-position to bottom
%   commentstyle=\color{mygreen},    % comment style
%   deletekeywords={...},            % if you want to delete keywords from the given language
%   escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
%   extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
%   inputencoding=utf8,
%   frame=single,                    % adds a frame around the code
%   keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
%   keywordstyle=\bf,       % keyword style
%   language=Refal,                    % the language of the code
% %   morekeywords={<,>,$ENTRY,Go,Arg, Open, Close, e., s., t., Get, Put}, 
%   							       % if you want to add more keywords to the set
%   numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
%   numbersep=5pt,                   % how far the line-numbers are from the code
%   xleftmargin=25pt,
%   xrightmargin=25pt,
%   numberstyle=\small\color{black}, % the style that is used for the line-numbers
%   rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
%   showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
%   showstringspaces=false,          % underline spaces within strings only
%   showtabs=false,                  % show tabs within strings adding particular underscores
%   stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
%   stringstyle=\color{mymauve},     % string literal style
%   tabsize=8,                       % sets default tabsize to 8 spaces
%   title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
% }
\newcommand{\anonsection}[1]{\cleardoublepage
\phantomsection
\addcontentsline{toc}{section}{\protect\numberline{}#1}
\section*{#1}\vspace*{2.5ex} % По госту положены 3 пустые строки после заголовка ненумеруемого раздела
}
\newcommand{\sectionbreak}{\clearpage}
\renewcommand{\sectionfont}{\normalsize} % Сбиваем стиль оглавления в стандартный
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}} % Точки в оглавлении напротив разделов

\renewcommand{\cftsecfont}{\normalfont\large} % Переключение на times в содержании
\renewcommand{\cftsubsecfont}{\normalfont\large} % Переключение на times в содержании

\usepackage{caption} 
%\captionsetup[table]{justification=raggedleft} 
%\captionsetup[figure]{justification=centering,labelsep=endash}
\usepackage{amsmath}    % \bar    (матрицы и проч. ...)
\usepackage{amsfonts}   % \mathbb (символ для множества действительных чисел и проч. ...)
\usepackage{mathtools}  % \abs, \norm
    \DeclarePairedDelimiter\abs{\lvert}{\rvert} % операция модуля
    \DeclarePairedDelimiter\norm{\lVert}{\rVert} % операция нормыw
\DeclareTextCommandDefault{\textvisiblespace}{%
  \mbox{\kern.06em\vrule \@height.3ex}%
  \vbox{\hrule \@width.3em}%
  \hbox{\vrule \@height.3ex}}    
\newsavebox{\spacebox}
\begin{lrbox}{\spacebox}
\verb*! !
\end{lrbox}
\newcommand{\aspace}{\usebox{\spacebox}}
\DeclareTotalCounter{listing}
    
    
\usepackage{tocloft}

% \renewcommand{\cfttoctitlefont}{\normalfont\Large}% Remove \bfseries from ToC title
% \renewcommand{\cftsecfont}{}% Remove \bfseries from section titles in ToC
% \renewcommand{\cftsecpagefont}{}% Remove \bfseries from section titles' page in ToC


% \newfontfamily\cyrillicfont{Times New Roman}
% %   \newfontfamily{\cyrillicfonttt}{CMU Typewriter Text}
% \setmainfont{Times New Roman}
% \newfontfamily\cyrillicfont{Times New Roman}
% \setsansfont{Times New Roman}                    %% задаёт шрифт без засечек
% \setmonofont{Liberation Mono}               %% задаёт моноширинный шрифт
\begin{document}
\sloppy

\def\figurename{Рисунок}

\begin{titlepage}
\thispagestyle{empty}
\newpage

\vspace*{-30pt}
\hspace{-45pt}
\begin{minipage}{0.17\textwidth}
\hspace*{-20pt}\centering
\includegraphics[width=1.3\textwidth]{emblem.png}
\end{minipage}
\begin{minipage}{0.82\textwidth}\small \textbf{
\vspace*{-0.7ex}
\hspace*{-10pt}\centerline{Министерство науки и высшего образования Российской Федерации}
\vspace*{-0.7ex}
\centerline{Федеральное государственное бюджетное образовательное учреждение }
\vspace*{-0.7ex}
\centerline{высшего образования}
\vspace*{-0.7ex}
\centerline{<<Московский государственный технический университет}
\vspace*{-0.7ex}
\centerline{имени Н.Э. Баумана}
\vspace*{-0.7ex}
\centerline{(национальный исследовательский университет)>>}
\vspace*{-0.7ex}
\centerline{(МГТУ им. Н.Э. Баумана)}}
\end{minipage}

\vspace{-2pt}
\hspace{-34.5pt}\rule{\textwidth}{0.5pt}

\vspace*{-18.3pt}
\hspace{-34.5pt}\rule{\textwidth}{2.5pt}
 
\vspace{0.5ex}
\noindent \small ФАКУЛЬТЕТ\hspace{80pt} <<Информатика и системы управления>>

\vspace*{-16pt}
\hspace{35pt}\rule{0.855\textwidth}{0.4pt}

\vspace{0.5ex}
\noindent \small КАФЕДРА\hspace{50pt} <<Теоретическая информатика и компьютерные технологии>>

\vspace*{-16pt}
\hspace{25pt}\rule{0.875\textwidth}{0.4pt}
 
 
\vspace{3em}
 
\begin{center}
\Large {\textbf{\uline{ОТЧЁТ ПО ПРОИЗВОДСТВЕННОЙ}}} \\ {\textbf{\uline{ПРАКТИКЕ}}}
\end{center}\normalsize

\vspace{2ex}
\noindent Студент \underline{\hspace{16pt}\footnotesize Емельяненко Дарья Сергеевна\hspace{228pt}}\normalsize

\vspace{-1.8ex}
\noindent\hspace{31ex} \scriptsize{(Фамилия, Имя, Отчество)}\normalsize

\vspace{0.7ex}
\noindent Группа \underline{\hspace{16pt}\footnotesize ИУ9-61Б\hspace{50pt}}\normalsize

\vspace{2ex}
\noindent Тип практики \underline{\hspace{16pt}\footnotesize Производственная\hspace{265pt}}\normalsize

\vspace{2.5ex}
\noindent Название предприятия \underline{\hspace{16pt}\footnotesize Институт Программных Систем им. А.К. Айламазяна РАН\hspace{12pt}}\normalsize

\vspace{\fill}
 

\noindent Студент \underline{\footnotesizeИУ9-61Б\hspace{1.5cm}} \hfill \underline{\hspace{4cm}}\quad
\underline{\hspace{4cm}}

\vspace{-2.1ex}
\noindent\hspace{9ex}\scriptsize{(Группа)}\normalsize\hspace{170pt}\hspace{2ex}\scriptsize{(Подпись, дата)}\normalsize\hspace{30pt}\hspace{6ex}\scriptsize{(И.О. Фамилия)}\normalsize

\bigskip

\noindent Рекомендуемая оценка\hfill\underline{\hspace{195pt}}\hfill

\bigskip

\noindent \parbox{0.333\textwidth}{Руководитель практики\\от предприятия}  
\hfill \underline{\hspace{4cm}}\quad \underline{\hspace{4cm}}

\vspace{-2ex}
\noindent\hspace{13.5ex}\normalsize\hspace{170pt}\hspace{2ex}\scriptsize{(Подпись, дата)}\normalsize\hspace{30pt}\hspace{6ex}\scriptsize{(И.О. Фамилия)}\normalsize


\bigskip

\noindent Руководитель практики  \hfill \underline{\hspace{4cm}}\quad
\underline{\hspace{4cm}}

\vspace{-2ex}
\noindent\hspace{13.5ex}\normalsize\hspace{170pt}\hspace{2ex}\scriptsize{(Подпись, дата)}\normalsize\hspace{30pt}\hspace{6ex}\scriptsize{(И.О. Фамилия)}\normalsize

\vspace{2ex}
\noindent Оценка\hfill\underline{\hspace{195pt}}

\vfill

%\vspace{\fill}
 


\begin{center}
\textsl{2023 г.}
\end{center}
\end{titlepage}

%\renewcommand{\ttdefault}{pcr}

\setlength{\tabcolsep}{3pt}
\newpage
\setcounter{page}{2}
%----------------------------------------------------------------------------
%                  ОТСЮДА --- СОБСТВЕННО ТЕКСТ
%----------------------------------------------------------------------------

\newpage
\renewcommand\contentsname{\hfill{\normalfont{СОДЕРЖАНИЕ}}\hfill}  %Оглавление
\tableofcontents
\newpage

\anonsection{ВВЕДЕНИЕ}  %Введение
Целью производственной практики на предприятии ИПС А.К. Айламазяна РАН является закрепление знаний по изучаемым дисциплинам 
и получение студентами практических навыков в период пребывания на предприятии, 
в связи с чем можно выделить следующие задачи данной практики:

\begin{enumerate}
  \item ознакомление с предприятием, его программными продуктами и предметной областью,
  для которой предназначены эти продукты;
  \item изучение новых дисциплин, связанных с предметной областью задания;
  \item применение навыков программирования и разработки алгоритмов ;
  \item получение опыта работы с руководителем и полноценным техническим заданием;
  \item обобщение полученных результатов и навыков, составление отчёта по практике.
\end{enumerate}

\section{Характеристика предприятия}
Производственная практика проходила в институте программных систем Российской академии наук ~\cite{IPS}.
Институт программных систем  был создан в апреле 1984 года как Филиал Института проблем кибернетики АН СССР по решению Правительства СССР, направленному на развитие вычислительной техники и информатики в стране. Руководителем ФИПК АН СССР был назначен д.т.н., профессор Альфред Карлович Айламазян. В 1986 году Филиал Института проблем кибернетики был преобразован в Институт программных систем АН СССР, а в 2008 году институту было присвоено имя его первого директора профессора А.К. Айламазяна.
С момента создания основными научными направлениями деятельности  института являлись:
\begin{itemize}
\item высокопроизводительные вычисления;
\item программные системы для параллельных архитектур;
\item автоматизация программирования;
\item телекоммуникационные системы и медицинская информатика.
\end{itemize}

Сегодня Институт программных систем имени А.К. Айламазяна РАН объединяет пять исследовательских центров и является одним из самых развивающихся коллективов, работающих в Отделении нанотехнологий и информационных технологий РАН.

Исследовательские центры ИПС РАН:
\begin{itemize}
\item Исследовательский центр мультипроцессорных систем (ИЦМС);
\item Исследовательский центр медицинской информатики (ИЦМИ Интерин);
\item Исследовательский центр искусственного интеллекта (ИЦИИ);
\item Исследовательский центр процессов управления (ИЦПУ);
\item Исследовательский центр системного анализа (ИЦСА).
\end{itemize}
\newpage

\section{Индивидуальное задание}

Функциональные языки программирования - это класс языков программирования, ориентированных на работу с функциями как основными строительными блоками программ. Они основываются на математическом понятии функции и применяют функциональные концепции в разработке программ.
        
Примером функционального языка выступает РЕФАЛ ~\cite{Refal5}. РЕФАЛ (РЕкурсивных Функций АЛгоритмический язык) - это функциональный язык программирования, ориентированный на обработку символьных строк (например, алгебраические выкладки), перевод с одного языка (искусственного или естественного) на другой, решение проблем, связанных с искусственным интеллектом. Данный язык программирования имеет различные диалекты, одним из которых является Рефал-5, проект которого поддерживается и оптимизируется в настоящее время ~\cite{RefalWiki}.

\subsection{Цель работы}
Цель работы - сравнение и  реализация на Си стандартного алгоритма умножения <<столбиком>> и алгоритма, основанного на Китайской теореме об остатках. Стоит отметить, что основная задача, поставленная передо мной на практике, имела экспериментальный характер, и от её результатов будут зависеть решения о развитии и оптимизации арифметики в системе Рефал-5.

\subsection{Поставленные задачи}
\begin{enumerate}
\item oзнакомление с необходимой теорией для реализации заданных алгоритмов;
\item реализация алгоритма перевода числа из 10-тичной системы счисления в систему счисления $2^{64}$
\item реализация стандартного алгоритма умножения на языке C;
\item реализация алгоритма умножения, основанного на Китайской теореме об остатках, на языке C;
\item генерирование различных тестовых данных;
\item измерение времени выполнения каждого алгоритма на тестовых данных;
\item сравнение результатов;
\item систематизация результатов тестирования в сравнительные таблицы.
\end{enumerate}

\subsection{Изучение предметной области}
Перед реализацией необходимо было ознакомиться с теорией, а именно вспомнить стандартный алгоритм перемножения <<столбиком>> для чисел в системе счисления $2^{64}$, Китайскую теорему об остатках, алгоритм, основанный на этой теореме. Также необходимо было ознакомиться с алгоритмом перевода из 10-тичной системы счисления в систему счисления по основанию $2^{64}$.

Исходя из условия поставленной задачи, ниже представлены алгоритмы, которые нужно было реализовать.

Алгоритм перевода из десятичной системы счисления в систему счисления по основанию $2^{64}$:
\begin{enumerate}
    \item число переводится в двоичную систему счисления алгоритмом стандартного деления в столбик;
    \item из двоичной системы счисления переводится в систему счисления по основанию $2^{64}$;
\end{enumerate}

Алгоритм стандартного умножения:
Пусть заданы два целых числа по основанию b - первое число $u_{1}u_{2}...u_{n}$, второе число $v_{1}v_{2}...v_{m}$. Алгоритм находит их произведение $w_{1}w_{2}...w_{m+n}$.
\begin{enumerate}
    \item устанавливаем все значения $w_{m+1}w_{m+2}...w_{m+n}$ равными нулю;
    \item устанавливаем j=m (индекс цифры второго сомножителя);
    \item если $v_{j}=0$, устанавливаем $w_{j}=0$ и передаем управление на шаг 8;
    \item устанавливаем i=n (индекс цифры первого сомножителя), k=0 (цифра переноса);
    \item устанавливаем t=$u_{i}*v_{j}+w_{i+j}+k$
    \item устанавливаем $w_{i+j}=t\mod{b}$, $k=[\frac{t}{b}]$;
    \item цикл по индексу i. Уменьшаем i на единицу, если i>0, то возвращаемся в шаг 5, иначе устанавливаем $w_{j}=k$;
    \item цикл по индексу j. Уменьшаем j на единицу, если j>0, то возвращаемся в шаг 3, иначе заканчиваем алгоритм.
\end{enumerate}
\begin{Example}\label{Example:MathFont5}
Умножение 621 на 201 в десятичной системе счисления
$$
\begin{array}{r}
*
\begin{array}{r}
621\\
201\\
\end{array} \\
\hline
+
\begin{array}{r}
621\\
000\,\,\,\,\\
1242\,\,\,\,\,\,\,\\
\end{array} \\
\hline
124821\,\,\,
\end{array}
$$
\textbf{Ответ:} $621*201 = 124821$ 
\end{Example}
\Newline
Алгоритм умножения, основанный на Китайской теореме об остатках ~\cite{Alghorythm_Chinese}:
\begin{enumerate}
    \item выполняем умножение двух чисел по стандартного алгоритму умножения в системе счисления $2_{64}$;
    \item задаем взаимно простые модули ($a_{1},a_{2}...a_{n}$);
    \item находим все остатки от деления получившегося числа на модули ($r_{1}r_{2}...r_{n}$), которые должны являться взаимно простыми числами;
    \item вычисляем M равный произведению всех модулей (M=$\displaystyle\ \Pi_{i=1}^{n}a_{i}$);
    \item для каждого модуля вычисляем  $\displaystyle\ M_{i}=\frac{M}{a_{i}}$;
    \item для каждого $M_{i}$ вычисляем его обратный элемент по модулю $a_{i}$  ($M{i}^{-1}\equiv\frac{1}{M_{i}}\mod a_{i}$);
    \item Вычисляем искомое значение по формуле $\displaystyle\ {x}\equiv \sum_{i=1}^{n} {r}_{i}{M}_{i}{M}_{i}^{-1} \mod {M}$
\end{enumerate}
При этом для корректной работы данного алгоритма должно выполняться следующее условия:
\begin{itemize}
    \item произведение входных чисел не должно превышать произведения всех модулей.
\end{itemize}
Для увеличения скорости работы алгоритма взаимно простые модули $a_{1}..a_{n}$ должны быть простыми числами Мерсенна. 
\Newline

\textbf{Число Мерсенна} - число вида $M_{n}=2^{n}-1$, где n - натуральное число; такие числа примечательны тем, что некоторые из них являются простыми при больших значениях n. Примеры простых чисел Мерсенна - 3, 7, 31, 127, 8191, 131 071, 524 287, 2 147 483 647 ~\cite{Mersen}.

\begin{Example}
Умножение 3675356 на 2912709, используя алгоритм умножения, основанный на Китайской теореме об остатках
\textup{
\begin{enumerate}
    \item выберем взаимно простые модули
    \begin{equation*}
        \begin{cases}
        a_{1}=3
        \\
        a_{2}=7
        \\
        a_{3}=31
        \\
        a_{4}=127
        \\
        a_{5}=8191
        \\
        a_{6}=131071
        \end{cases}
    \end{equation*}
    \item находим результат умножения по стандартному алгоритму - 3675356*2912709=10705242499404;
    \item найдем все $r_{1}...r_{n}$
    \begin{equation*}
        \begin{cases}
        r_{1}=0,
        \\
        r_{2}=5, 
        \\
        r_{3}=18,
        \\
        r_{4}=102,
        \\
        r_{5}=2537,
        \\
        r_{6}=93393.
        \end{cases}
    \end{equation*}
    \item вычислим M=3*7*31*127*8191*131071=88762238935797;
    \item вычислим все $M_{i}$
     \begin{equation*}
        \begin{cases}
        M_{1}=29587412978599
        \\
        M_{2}=12680319847971, 
        \\
        M_{3}=2863298030187,
        \\
        M_{4}=698915267211,
        \\
        M_{5}=10836557067,
        \\
        M_{6}=677207307.
        \end{cases}
    \end{equation*}
    \item вычислим обратные элементы к $M_{i}$
    \begin{equation*}
        \begin{cases}
        M_{1}^{-1}=1, 
        \\
        M_{2}^{-1}=6,
        \\
        M_{3}^{-1}=3,
        \\
        M_{4}^{-1}=34,
        \\
        M_{5}^{-1}=5969,
        \\
        M_{6}^{-1}=93887.
        \end{cases}
    \end{equation*}
    \item вычислим искомое значение x = $((0*29587412978599*1)\mod88762238935797+(5*12680319847971*6)\mod88762238935797+(18*2863298030187*3)\mod88762238935797+(102*698915267211*34)\mod88762238935797+(2537*10836557067*5969)\mod88762238935797+(93393*677207307*93887)\mod88762238935797)\mod88762238935797$=10705242499404
\end{enumerate}
}
\textbf{Ответ:} $3675356*2912709=10705242499404$ 
\end{Example}

\subsection{Разработка и реализация}
Для достижения поставленной задачи был реализован программный продукт на языке С в программе Visual Studio Code. В результате были реализованы необходимые алгоритмы, которые принимают на вход числа произвольной длины и возвращают результат умножения  этих чисел. Все данные считываются из файла input и возвращаются в виде файла output, который в случае корректной работы, то есть одинакового ответа алгоритма путем стандратного умножения и алгоритма, основанного на Китайской теореме об остатках, содержит информацию о длине чисел, а также времени работы каждого алгоритма. В случае некорректной работы файл содержит информацию о тесте, на котором произошла поломка, а также ответы, которые выдали два алгоритма. 

\subsection{Особенности программы}
Для реализации заданных алгоритмов необходимо было решить несколько проблем. Первая из них - хранение больших чисел в памяти компьютера. Для этого было решено использовать структуру, которая представляет из себя структуру, близкую к той, которую используют в  используют в реализации интерпретатора Рефала-5 для представления элементарных данных (термов) языка Рефал ~\cite{Refal5}.
\label{lst:refal}
\begin{minted}[frame=single,fontsize = \footnotesize, linenos, breaklines = True, xleftmargin = 1.5em,breaksymbol = ""]{c}
/*** Refal structures. ***/
typedef struct link {
    char ptype; /* type of the link */  
    union {
        struct link *b; /* bracket: ptr to the pair */
        char *f; /* function or compound symbol: ptr to label. */
        char c; /* symbol: actual value. */
        /* unsigned long u; /+* unicode symbol */
        unsigned int u;  /* unicode symbol */
        unsigned long n; /*  macro-digit   */
        unsigned short us_1, us_2;
    } pair;
    struct link *prec; /* ptr to preceding link */
    struct link *foll; /* ptr to following link */
} LINK;
\end{minted}

По условию задачи необходимо было работать с числами в системе счисления $2^{64}$, но одна цифра может превышать максимальное значение типа unsigned long в C, поэтому было принято решение хранить числа в системе счисления $2^{32}$ при этом число может быть легко представлено в нужной системе счисления. Для этого достаточно взять два разряда и домножить старший разряд на $2^{32}$, данное умножение можно произвести простым побитовым сдвигом на 32 бита влево.

Следующая проблема, которая возникла передо мной, заключалась в реализации алгоритма, основанного на Китайской теореме об остатках. Для выполнения первого шага, то есть нахождения остатков от деления, необходимо было реализовать алгоритм деления в системе счисления $2^{64}$. Стандратный алгоритм деления столбиком не подходит для больших систем счисления, так как компьютер будет долго <<угадывать>> необходимую цифру. Решение данной проблемы - использование алгоритма деления, используемого при реализации языка FLAC, который является диалектом Рефала~\cite{FLAC}.

Алгоритм:

Пусть первое число $n_{1}=a_{n}a_{n-1}...a_{0}$, второе число $n_{2}=b_{m}b_{m-1}...b_{0}$
\begin{itemize}
    \item необходимо найти $\delta=min([\frac{a_{n}*\beta+a_{n-1}}{b_{m}},\beta-1])$;
    \item домножаем делимое и делитель на $\delta$ - $a_{n}a_{n-1}...a_{0}*\beta=a_{l}a_{l-1}...a_{0}$, $b_{m}b_{m-1}...b_{0}*\beta=b_{k}b_{k-1}...b_{0}$;
    \item если $a_{l}\geq b_{k}$, то в ответ записывается цифра 1;
    \item иначе цифра = $ min([\frac{a_{l}*\beta+a_{l-1}}{b_{m}},\beta-1])$;
    \item домножаем делитель на цифру и проверяем, что число меньше, чем делимое, иначе уменьшаем цифру на 1;
    \item повторяем предыдущие шаги, пока число не становится меньше делимого.
\end{itemize}

Последней проблемой стало нахождение обратного числа по определенному модулю.
Алгоритм для его нахождения:
\begin{itemize}
    \item используем расширенный алгоритм Евклида для нахождения x и y, таких что ax+ny=d, где d - наибольший общий делитель a,n ~\cite{Euclid};
    \item если d>1, то обратного элемента не существует, иначе возвращаем x.
\end{itemize}

\section{Тестирование}
Целью тестирования - сравнение двух алгоритмов по времени их выполнения с целбю определения наиболее быстрого варианта. 

Реализованная программа была протестирована на входных десятичных числах разной длины. Результаты были систематизированы в сравнительные таблицы ~\ref{table:table11}.

\Newline
\begin{table}[!htb]
\caption{\centering Среднее время работы стандартного и нового алгоритмов умножения в системе счисления по основанию $2^{64}$.}
\small
\centering\begin{tabular}{|c|c|c|}
\hline
\multirow{ 2}{*}{Длина входного \vspace{2em}} & \multirow{ 2}{*}{Время выполнения стандартного \vspace{2em}} & \multirow{ 2}{*}{Время выполнения \vspace{2em}} \\
десятичного числа & алгоритма, с. &  Китайской теоремы об остатках, с.\\
\hline
1 & 0.000001 & 0.000003 \\
\hline
2 & 0.000001  & 0.00001 \\
\hline
4 & 0.000001 & 0.00003 \\
\hline
8 & 0.000001 & 0.000031 \\
\hline
16 & 0.000001 & 0.000008 \\
\hline
20 & 0.000001 & 0.000045 \\
\hline
32 & 0.000003 & 0.00050 \\
\hline
64 & 0.000007 & 0.00055 \\
\hline
128 & 0.00002 & 0.0003\\
\hline
\end{tabular}
\label{table:table11}
\end{table}

\subsection{Вывод}
Таким образом, сравнивая времена двух алгоритмов, для чисел, длина которых в десятичной системе не превышает 128 символов, можно сделать вывод о том, что стандартный алгоритм работает быстрее, чем алгоритм, основанный на Китайской теореме об остатках. Происходит это по причине дополнительных затрат времени на алгоритм деления, который активно используется во втором алгоритме, наибольший выигрыш прослеживается когда разложение модуля состоит из одного простого числа. 
Возможным решением проблемы является оптимизация алгоритма деления.



\anonsection{ЗАКЛЮЧЕНИЕ}
В результате практики поставленные задачи были успешно выполнены. 
Я изучила необходимую теорию для реализации  стандартного алгоритма умножения, а также алгоритма, основанного на Китайской теореме об остатках. Также создала функцию, которая переводит число из десятичной системы счисления в число в системе счисления по основанию $2^{64}$. Мною был реализован стандратный алгоритм умножения длинных чисел, а также алгоритм умножения длинных чисел, основанный на Китайской теореме об остатках. Также были реализованы функции необходимые для корректной работы вышеперечисленных алгоритмов, а именно вся арифметика для чисел по основанию $2^{64}$ и расширенный алгоритм Евклида для нахождения обратного элемента по заданному модулю. Также была создана функция, которая способна генерировать примеры, содержащие числа, заданной пользователем длины. На данных примерах была протестирована работа стандартного алгоритма умножения, а также алгоритма, основанного на Китайской теореме об остатках, и было осуществлено сравнение времен выполнения вышеперечисленных алгоритмов. 

В ходе разработки был получен опыт работы с языком программирования Си. Результаты работы  подтвердили гиппотезу о том, что умножение больших чисел, основанное на Китайской теореме об остатках, работает быстрее, чем стандатный алгоритм умножения, но на числах очень большой длины. Таким образом для вычисления умножения чисел небольшой длины рекомендуется использовать стандартный алгоритм умножения. 

В дальнейшем видится совершенствование проекта, а именно усовершенствование алгоритма деления и нахождения остатка по модулю по причине уменьшения времени выполнения алгоритма, основанного на Китайской теореме об остатках, и улучшения его работоспособности на небольших числах (числах длины $\leq$ 128). 

\newenvironment{code}{\captionsetup{type=listing}}{}

\newpage
\renewcommand\refname{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
% Список литературы
\clearpage
%\bibliographystyle{ugost2008s}  %utf8gost71u.bst} %utf8gost705u} %gost2008s}
{\catcode`"\active\def"{\relax}
\addcontentsline{toc}{section}{\protect\numberline{}\refname}%
%\bibliography{biblio} %здесь ничего не меняем, кроме, возможно, имени bib-файла
\printbibliography
}
\newpage

\settocdepth{section}
\anonsection{ПРИЛОЖЕНИЕ А}
\vspace{-20pt}
\begin{code}
\caption{Реализация стандартного алгоритма умножения}
\vspace{10pt}
\label{lst:mul2octal}
\begin{minted}[frame=single,fontsize = \footnotesize, linenos, breaklines = True, xleftmargin = 1.5em,breaksymbol = "", escapeinside=``]{c}
LINK* alghorithm_multyplication(LINK* first_num,LINK* second_num){
    LINK* res=NULL;
    res=(LINK*)malloc(sizeof(LINK));
    res->foll=NULL;
    res->prec=NULL;
    if (((first_num->ptype=='d')&&(second_num->ptype=='n'))||((first_num->ptype=='n')&&(second_num->ptype=='d'))) res->ptype='n';
    else res->ptype='d';
    res->pair.n=0;
    unsigned long long size_first_num=Size_Link(first_num);
    unsigned long long size_second_num=Size_Link(second_num);
    if (((size_first_num==1)&&(first_num->pair.n==0))||((size_second_num==1)&&(second_num->pair.n==0))) return res;
    if ((size_first_num>size_second_num)||(size_first_num==size_second_num)){
        LINK* dop_for_dop_res2=NULL;
        LINK* dop_for_res=res;
        LINK* dop_for_res2=res;
        LINK* dop_for_first_num=first_num;
        while (second_num!=NULL){
        while (dop_for_first_num!=NULL){
            unsigned long long mnog=0;
            unsigned long mainpart=0;
            unsigned long ost=0;
            //Проверка на переполнение
            if (dop_for_res2==NULL){
                dop_for_res2=(LINK*)malloc(sizeof(LINK));
                dop_for_res2->ptype='d';
                dop_for_res2->foll=NULL;
                dop_for_res2->prec=dop_for_dop_res2;
                dop_for_res2->pair.n=0;
            }
                mnog=second_num->pair.n*dop_for_first_num->pair.n;
                mnog=dop_for_res2->pair.n+mnog;
                if (mnog){
                    mainpart=mnog>>32;
                    ost=mnog-(mainpart<<32);
                }
                else{
                    mainpart=0;
                    ost=0;
                }
            dop_for_res2->pair.n=ost;
                if (dop_for_res2->foll==NULL){
                    dop_for_res2->foll=(LINK*)malloc(sizeof(LINK));
                    dop_for_res2->foll->ptype='d';
                    dop_for_res2->foll->pair.n=0;
                    dop_for_res2->foll->foll=NULL;
                    dop_for_res2->foll->prec=dop_for_res2;
                }
                dop_for_res2->foll->pair.n+=mainpart;
            dop_for_dop_res2=dop_for_res2;
            dop_for_res2=dop_for_res2->foll;
            dop_for_first_num=dop_for_first_num->foll;
        }
        dop_for_first_num=first_num;
        second_num=second_num->foll;
        dop_for_res=dop_for_res->foll;
        dop_for_res2=dop_for_res;
        }
    }
    else{
        LINK* dop_for_dop_res2=NULL;
        LINK* dop_for_res=res;
        LINK* dop_for_res2=res;
        LINK* dop_for_second_num=second_num;
        while (first_num!=NULL){
        while (dop_for_second_num!=NULL){
            unsigned long long mnog=0;
            mnog=first_num->pair.n*dop_for_second_num->pair.n;
            if (dop_for_res2==NULL){
                dop_for_res2=(LINK*)malloc(sizeof(LINK));
                dop_for_res2->ptype='d';
                dop_for_res2->foll=NULL;
                dop_for_res2->prec=dop_for_dop_res2;
                dop_for_res2->pair.n=0;
            }
            mnog=dop_for_res2->pair.n+mnog;
            unsigned long mainpart=mnog>>32;
            unsigned long ost=mnog-(mainpart<<32);
            dop_for_res2->pair.n=ost;
                if (dop_for_res2->foll==NULL){
                    dop_for_res2->foll=(LINK*)malloc(sizeof(LINK));
                    dop_for_res2->foll->ptype='d';
                    dop_for_res2->foll->pair.n=0;
                    dop_for_res2->foll->foll=NULL;
                    dop_for_res2->foll->prec=dop_for_res2;
                }
                dop_for_res2->foll->pair.n+=mainpart;
            dop_for_dop_res2=dop_for_res2;
            dop_for_res2=dop_for_res2->foll;
            dop_for_second_num=dop_for_second_num->foll;
        }
        dop_for_second_num=second_num;
        first_num=first_num->foll;
        dop_for_res=dop_for_res->foll;
        dop_for_res2=dop_for_res;
        }    
    }
    if (res!=NULL) res=DELETE_ZERROW(res);
    return res;
}
\end{minted}
\end{code}


\newpage
\begin{code}
\caption{Реализация Китайской теоремы об остатках}
\label{lst:octaladd}
\begin{minted}[frame=single,fontsize = \footnotesize, linenos, breaklines = True, xleftmargin = 1.5em,breaksymbol = "", escapeinside=``]{c}
LINK* chinese_theorema(M_I* m_i,M_I* r_i,LINK* M,M_I* y_i){
    LINK* x=(LINK*)malloc(sizeof(LINK));
    x->foll=NULL;
    x->pair.n=0;
    x->prec=NULL;
    x->ptype='d';
    while (m_i!=NULL){
        char* check;
        LINK* s_i=extended_euclid(y_i->num,m_i->num);
        LINK* c_i=alghorithm_multyplication(r_i->num,s_i);
        c_i=FIND_MOD(c_i,m_i->num);
        LINK* x_dop=NULL;
        x_dop=alghorithm_multyplication(c_i,y_i->num);
        x_dop=FIND_MOD(x_dop,M);
        x=ADD_LINK(x,x_dop);
        m_i=m_i->next;
        r_i=r_i->next;
        y_i=y_i->next;
    }
    x=FIND_MOD(x,M);
    if ((Size_Link(x)!=1)&&(x->pair.n!=0)) x=DELETE_ZERROW(x);
    return x;

}
\end{minted}
\end{code}

\newpage
\begin{code}
\caption{Реализация алгоритма деления в системе счисления по основанию 2^{64}}
\label{lst:octaladd}
\begin{minted}[frame=single,fontsize = \footnotesize, linenos, breaklines = True, xleftmargin = 1.5em,breaksymbol = "", escapeinside=``]{c}
LINK* Div_in_32_system(LINK*a, LINK* b){
    if ((a==NULL)||(b==NULL)) return NULL;
    if (Compare(a,b)==-1){
        LINK* res;
        res=(LINK*)malloc(sizeof(LINK));
        res->pair.n=0;
        res->foll=NULL;
        res->prec=NULL;
        res->ptype='d';
        return res;
    }
    if (((Size_Link(a)==Size_Link(b))&&(Size_Link(a)==1))){
        if (!b->pair.n){
            printf("Деление на 0 запрещено\n");
            return NULL;
        }
        LINK* res;
        res=(LINK*)malloc(sizeof(LINK));
        unsigned long long res1=a->pair.n/b->pair.n;
        if ((res1)&&(((a->ptype=='d')&&(b->ptype=='n'))||((a->ptype=='n')&&(b->ptype=='d')))) res->ptype='n';
        else res->ptype='d';
        res->prec=NULL;
        res->foll=NULL;
        res->pair.n=res1;
        return res;
    }
    if ((Size_Link(a)==1)&&(a->pair.n==0)){
        LINK* res;
        res=(LINK*)malloc(sizeof(LINK));
        res->foll=NULL;
        res->pair.n=0;
        res->prec=NULL;
        res->ptype='d';
        return res;
    }
    LINK* bn=reverse(b);
    LINK* normal_a;
    LINK* normal_b;
    LINK* vector_for_normalization=NULL;
    vector_for_normalization=(LINK*)malloc(sizeof(LINK));
    vector_for_normalization->ptype='d';
    vector_for_normalization->prec=NULL;
    unsigned long long base=4294967296;
    vector_for_normalization->pair.n=(unsigned long) (base/(bn->pair.n+1));
    vector_for_normalization->foll=NULL;
    unsigned long long base_without_1=4294967296-1;
    normal_a=alghorithm_multyplication(a,vector_for_normalization);
    normal_b=alghorithm_multyplication(b,vector_for_normalization);
    //Результат
    LINK* res;
    res=(LINK*)malloc(sizeof(LINK));
    res->foll=NULL;
    res->prec=NULL;
    res->pair.n=0;
    res->ptype='d';
    LINK* normal_a_reverse;
    LINK* normal_b_reverse;
    normal_a_reverse=reverse(normal_a);
    normal_b_reverse=reverse(normal_b);
    //Остаток
    LINK* q;
    q=(LINK*)malloc(sizeof(LINK));        
    q->foll=NULL;
    q->pair.n=normal_a_reverse->pair.n;
    q->prec=NULL;
    q->ptype='d';
    unsigned long long first_num=normal_a_reverse->pair.n;
    unsigned long long second_num=normal_a_reverse->prec->pair.n;
    while (Compare(q,normal_b)==-1){
        if (normal_a_reverse->prec==NULL){
            LINK* ost;
            ost=(LINK*)malloc(sizeof(LINK));
            ost->foll=NULL;
            ost->ptype='d';
            ost->prec=NULL;
            ost->pair.n=0;
            return ost;
        }
        normal_a_reverse=normal_a_reverse->prec;
        q->prec=malloc(sizeof(LINK));
        q->prec->ptype='d';
        q->prec->foll=q;
        q->prec->pair.n=normal_a_reverse->pair.n;
        q->prec->prec=NULL;
        q=q->prec;
    }
    if (first_num>=normal_b_reverse->pair.n){
        res->pair.n=1;
        LINK* mnog;
        mnog=alghorithm_multyplication(normal_b,res);
        q=SUB_LINK(q,mnog);
    }
    else{
        LINK* delta;
        delta=(LINK*)malloc(sizeof(LINK));
        delta->ptype='d';
        delta->foll=NULL;
        delta->prec=NULL;
        unsigned long long num=(first_num<<32)/normal_b_reverse->pair.n;
        unsigned long long num2=second_num/normal_b_reverse->pair.n;
        num=num+num2+2;
        if (num<=base_without_1) {
            delta->pair.n=num;
        }
        else delta->pair.n=base_without_1;
        while (true){
            LINK* mnog;
            mnog=alghorithm_multyplication(delta,normal_b);
            if (Compare(mnog,q)==1) delta->pair.n-=1;
            else break;
        }
        res->pair.n=delta->pair.n;
        LINK* mnog;
        mnog=alghorithm_multyplication(res,normal_b);
        q=SUB_LINK(q,mnog);
        free(delta);
    }
    if (normal_a_reverse->prec==NULL) {
        if (((a->ptype=='d')&&(b->ptype=='n'))||((a->ptype=='n')&&(b->ptype=='d'))) res->ptype='n';
        return res;
    }
    while (normal_a_reverse!=NULL){
        normal_a_reverse=normal_a_reverse->prec;
        if (normal_a_reverse==NULL) break;
        q->prec=(LINK*)malloc(sizeof(LINK));
        q->prec->ptype='d';
        q->prec->foll=q;
        q->prec->pair.n=normal_a_reverse->pair.n;
        q->prec->prec=NULL;
        q=q->prec;
        LINK* reverse_q=reverse(q);
        first_num=reverse_q->pair.n;
        if (reverse_q->prec==NULL) second_num=0;
        else second_num=reverse_q->prec->pair.n;
        if (Compare(q,normal_b)==-1){
            res->prec=(LINK*)malloc(sizeof(LINK));
            res->prec->ptype='d';
            res->prec->foll=res;
            res->prec->prec=NULL;
            res->prec->pair.n=0;
            res=res->prec;
            continue;
        }
        if (first_num>=normal_b_reverse->pair.n){
            res->prec=(LINK*)malloc(sizeof(LINK));
            res->prec->ptype='d';
            res->prec->foll=res;
            res->prec->prec=NULL;
            res->prec->pair.n=1;
            res=res->prec;
            LINK* for_one_num;
            for_one_num=(LINK*)malloc(sizeof(LINK));
            for_one_num->ptype='d';
            for_one_num->prec=NULL;
            for_one_num->foll=NULL;
            for_one_num->pair.n=1;
            LINK* mnog;
            mnog=alghorithm_multyplication(normal_b,for_one_num);
            free(for_one_num);
            q=SUB_LINK(q,mnog);
            continue;
        }
        else{
            LINK* delta;
            delta=(LINK*)malloc(sizeof(LINK));
            delta->foll=NULL;
            delta->ptype='d';
            delta->prec=NULL;
            delta->pair.n=0;
            unsigned long long num=(first_num<<32)/normal_b_reverse->pair.n;
            unsigned long long num2=second_num/normal_b_reverse->pair.n;
            num=num+num2+2;
            if (num<=base_without_1) {
                delta->pair.n=num;
            }
            else delta->pair.n=base_without_1;
            while (true){
                LINK* mnog;
                mnog=alghorithm_multyplication(delta,normal_b);
                if (Compare(mnog,q)==1){
                    delta->pair.n-=1;
                } 
                else break;
            }
            res->prec=(LINK*)malloc(sizeof(LINK));
            res->prec->ptype='d';
            res->prec->foll=res;
            res->prec->prec=NULL;
            res->prec->pair.n=delta->pair.n;
            res=res->prec;
            LINK* mnog;
            mnog=alghorithm_multyplication(delta,normal_b);
            q=SUB_LINK(q,mnog);
        }
    }
    if (((a->ptype=='d')&&(b->ptype=='n'))||((a->ptype=='n')&&(b->ptype=='d'))) res->ptype='n';
    return res;
    
}

\end{minted}
\end{code}

\newpage
\begin{code}
\caption{Реализация расширенного алгоритма Евклида}
\label{lst:octaladd}
\begin{minted}[frame=single,fontsize = \footnotesize, linenos, breaklines = True, xleftmargin = 1.5em,breaksymbol = "", escapeinside=``]{c}
LINK* extended_euclid(LINK*a, LINK*b){
    if ((a==NULL)||(b==NULL)) return NULL;
    LINK* x=NULL;
    LINK* d=NULL;
    LINK* Zerrow=NULL;
    Zerrow=(LINK*)malloc(sizeof(LINK));
    Zerrow->ptype='d';
    Zerrow->foll=NULL;
    Zerrow->prec=NULL;
    Zerrow->pair.n=0;
    if ((Size_Link(b)==1)&&(b->pair.n)==0){
        if ((Size_Link(a)==1)&&(a->pair.n==1)){
            LINK* res=(LINK*)malloc(sizeof(LINK));
            res->foll=NULL;
            res->prec=NULL;
            res->ptype='d';
            res->pair.n=1;
            return res;
        }
        else{
            printf("ERROR!\n");
            LINK* res=(LINK*)malloc(sizeof(LINK));
            res->foll=NULL;
            res->prec=NULL;
            res->ptype='d';
            res->pair.n=0;
            return res;
        }
    }
    LINK* x2=(LINK*)malloc(sizeof(LINK));
    x2->foll=NULL;
    x2->pair.n=1;
    x2->prec=NULL;
    x2->ptype='d';

    LINK* x1=(LINK*)malloc(sizeof(LINK));
    x1->foll=NULL;
    x1->pair.n=0;
    x1->prec=NULL;
    x1->ptype='d';

    LINK* q=NULL;
    LINK* r=NULL;

    LINK* first_num=COPY_LINK_1(a);
    LINK* second_num=COPY_LINK_1(b);

    while (true){
        if ((second_num!=NULL)&&(second_num->ptype=='n')) break;
        if ((second_num!=NULL)&&(Size_Link(second_num)==1)&&(second_num->pair.n==0)) break;
        q=Div_in_32_system(first_num,second_num);
        r=alghorithm_multyplication(q,second_num);
        r=SUB_LINK(first_num,r);
        x=alghorithm_multyplication(q,x1);
        x=SUB_LINK(x2,x); 
        first_num=second_num;
        second_num=r;
        x2=x1;
        x1=x;    
    }
    while (x2->ptype=='n'){
       x2=ADD_LINK(x2,b);
    }
    if ((Size_Link(first_num)==1)&&(first_num->pair.n==1)) return x2;
    printf("ERRRRRRRRRROR!!!!\n");
    LINK* res=(LINK*)malloc(sizeof(LINK));
    res->foll=NULL;
    res->prec=NULL;
    res->ptype='d';
    res->pair.n=0;
    return res;
}
\end{minted}
\end{code}



\end{document}
